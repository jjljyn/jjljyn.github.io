[{"title":"Shell杀死指定进程","url":"/2018/11/14/shell-kill-specified-process/","content":"```bash\n#!/bin/sh\n\n# 用法：\n# $ bash kill_all.sh configs_local.js\n\nNAME=$1\n\nif [ -z $1 ];then\n\necho \"Hint enter for default process name 'configs_local.js'.\"\nread\nNAME='configs_local.js'\n\nfi\n\nread -p \"Do you really want to kill all process which is match '$NAME'?(Y/n).\" -n 1 FLAG\necho -e \"\\n\"\n\nif [[ -n \"$FLAG\" && $FLAG = 'Y' ]];\nthen\n\necho \"Process name include '$NAME' \"\nID=`ps -ef | grep \"$NAME\" | grep -v \"$0\" | grep -v \"grep\" | awk '{print $2}'`\necho $ID\necho \"---------------\"\nfor id in $ID\ndo\nkill -9 $id\necho \"killed $id\"\ndone\necho \"---------------\"\n\nelse\n\necho 'Bye Bye';\n\nfi\n```\n1. 将之保存为`killprocess.sh`\n2. 调用`./killprocess.sh programmename`。其中`programme`可以为程序名字，也可以是启动程序时的命令行，只要能在`ps -ef | grep programmename` 之后出现所有的该程序对应的进程即可\n\n\n> `awk`命令简介：\n> awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。\n\n基础用法见：[linux awk命令详解](https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html)。\n\n详习用法见：[The GNU Awk User’s Guide](http://www.gnu.org/software/gawk/manual/gawk.html)","tags":["shell","node.js"]},{"title":"this、call和apply","url":"/2018/11/13/this-call-apply/","content":"> `JavaScript`中的`this`总是指向一个对象，具体指向哪个对象是**「在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境」。**\n\n# this\n\n`this`的指向大致分为四种：\n\n## 1. 作为对象的方法引用\n\n当某个对象中有函数作为属性并且被调用时，函数中的`this`会指向当前对象。\n```javascript\nvar obj = {\n  a:1,\n  getA: function() {\n    console.log(this === obj)   // 输出：true \n    console.log(this.a)   //  输出：1\n  }\n};\n```\n\n## 2. 作为普通函数调用\n\n普通的函数中包含`this`并且被调用时，`this`总是指向全局对象。浏览器中的全局对象就是`window`对象。\n```javascript\nwindow.name = 'window';\n\nvar getName = function() {\n  return this.name;\n};\nconsole.log(getName())  // 输出：window\n```\n\n## 3. 构造器调用\n\n**Javascript中没有类**，但是可以从构造器中创建对象，同时也提供了`new`运算符，使得构造器看起来更像一个类。\n当用`new`运算符调用函数时，总会返回一个对象，通常情况下，构造器里的`this`就指向返回的这个对象。\n```javascript\nvar name = function() {\n  this.name = 'steven';\n};\n\nvar obj = new name();\nconsole.log(obj.name)  //输出：steven\n```\n但用`new`调用构造器时，需要注意如果**显式**的返回一个`object`对象，那么`this`会指向这个返回的对象。如果显式返回一个非`object`的类型则不会影响。\nvar name = function() {\n  this.name = 'steven';\n  return {\n    name: 'John'\n  }\n};\n\nvar obj = new name();\nconsole.log(obj.name)  //输出：John\n\n\n## 4.  `Function.prototype.call`或者`Function.prototype.apply`调用\n\n用`Function.prototype.call`或者`Function.prototype.apply`可以动态改变传入函数的`this`。\n```javascript\nvar person1 = {\n  name: 'steven',\n  getName: function() {\n    return this.name\n  }\n};\n\nvar person2 = {\n  name: 'John'\n}\n\nconsole.log(person1.getName())  // 输出：steven\nconsole.log(person1.getName.call(person2))   // 输出：John\n```\n\n\n# call和apply的区别 \n\n`Function.prototype.call`和`Function.prototype.apply`都是非常常用的方法。它们的作用一模一样，区别仅在于传入参数形式的不同。\n\n详细用法参见[MDN web docs Function.prototype.call](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)、[MDN web docs Function.prototype.apply](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n\n# call和apply的用途 \n\n## 1. 改变`this`指向\n### '丢失'的`this`\n```html\n<html>\n    <body>\n        <div id=\"div1\">我是一个div</div>\n    </body>\n    <script>\n\n    var getId = document.getElementById;\n    getId( 'div1' );\n\n    </script>\n</html>\n```\n上述代码执行时会报错，因为调用`getId()`时，相当于调用普通函数，则`document.getElementById`中内部实现需要用到的`this`默认指向全家对象`window`并不是原本期望的`document`。\n\n```javascript\ndocument.getElementById = (function(fn) {\n  return function() {\n    return fn.apply(document, arguments)  // apply 中第一个参数 document 就是将 document.getElementById内部的this指向到document\n  }\n})(document.getElementById);  // 这里括号内的方法 document.getElementById 就是上方的 fn\n\nvar getId = document.getElementById;\ngetId('div')\n```\n> `(function(){ /* code */})();`是[IIFE立即执行函数模式](https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F)语法，可以让函数在定义后立即被执行。\n> 第一部分是包围在圆括号运算符()里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。\n  第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。\n\n## 2. `Function.prototype.bind`\n\n大部分高级浏览器都实现了内置的`Function.prototype.bind`，用来指定函数内部的`this`指向，我们来实现一下`Function.prototype.bind`，代码如下：\n\n```javascript\nFunction.prototype.bind = function( context ){\n    var self = this;        // 保存原函数\n    return function(){        // 返回一个新的函数\n        return self.apply( context, arguments );    // 执行新的函数的时候，会把之前传入的context\n                                                    // 当作新函数体内的this\n    }\n};\n\nvar obj = {\n    name: 'sven'\n};\n\nvar func = function(){\n    console.log ( this.name );    // 输出：sven\n}.bind( obj);\n\nfunc();\n```\n## 3. 借用其他对象的方法\n\n函数的参数列表`arguments`是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，我们常常会借用`Array.prototype`对象上的方法。比如想往`arguments`中添加一个新的元素，通常会借用`Array.prototype.push`：\n```javascript\n(function(){\n  console.log(arguments);   // 输出：Arguments(2) [1,2]\n  Array.prototype.push.call( arguments, 3 );\n  console.log ( arguments );    // 输出：Arguments(3) [1,2,3]\n})( 1, 2 );\n```\n\n>`本文内容摘自《Javascript设计模式与实际开发》，如有疑问请评论。`","tags":["Javascript"]},{"title":"Javascript设计模式1 -- 原型模式","url":"/2018/11/06/javascript-design-1/","content":"### 原型模式\n原型模式是一种设计模式，也是一种编程泛型，它构成了JavaScript这门语言的根本。\n\n原型模式的实现关键，是语言本身是否提供了`clone`方法。ECMAScript5提供了`Object.create`方法，可以用来克隆对象。代码如下\n```javascript\n// 例如是在写一个飞机大战的游戏\nvar Plane = function () {\n  this.blood = 100;\n  this.attackLevel = 1;\n  this.defenseLevel = 1;\n}\n\nvar plane =  new Plane();\nplane.blood = 500;\nplane.attackLevel = 10;\nplane.defenseLevel = 5;\n\nvar clonePlane = Object.create(plane);\nconsole.log(clonePlane.blood)  // 500\nconsole.log(clonePlane.attackLevel)   // 10\nconsole.log(clonePlane.defenseLevel)  // 5\n```\n在不支持`Object.create`方法的浏览器中，则可以使用以下代码\n```javascript\nObject.create = Object.create || function(obj) {\n  var fn = function() {};\n  fn.prototype = obj;\n  return new fn();\n}\n```\n\n### 原型编程范型的一些规则\nJavaScript本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的。所以原型模式不仅仅是一种设计模式，也是一种编程范型。\n\n原型编程中的一个重要特性，即当对象无法响应某个请求时，会把该请求委托给它自己的原型。\n\n原型编程范型至少包括以下基本规则：\n- 所有数据都是对象\n- 要得到一个对象，不是用过实例化类，而是找到一个对象作为原型并克隆它\n- 对象会记住它的原型\n- 如果对象无法响应某个请求，它会把这个请求委托给自己的原型。\n\n\n\n>`本文内容摘自《Javascript设计模式与实际开发》，如有疑问请评论。`","tags":["设计模式","JavaScript"]},{"title":"新的开始","url":"/2018/11/01/hello-world/","content":"\n### 新的开始\n\n一直想有个地方，专门承载一些自己的小兴趣，记录自己的成长\n\n用过简书，虽然很好的支持Markdown，但是草稿多了搜索是个问题，所以暂时不用了。\n\n用过Evernote，虽然支持多端使用，但是不支持Markdown语法而且太封闭，加上自己又有输出和交流的念头，所以记录项目和写草稿。\n\n那这个个人的小网站就是能满足自己需求的地方。\n\n做技术是一个积累的过程，积累到一定程度是能够输出的，而且也会有及积极输出的欲望。\n\n就目前来说，自己积累沉淀的内容质量并不高，适合自己的方式方法、主题及内容尚未成型\n\n希望能看到内容的朋友能够多多给予意见和建议，以及一些正面反馈。\n\n上小学的时候，学校举办一次自制校报的比赛，我就很没有创意的起名叫做\"杂报\"，\n\n而且用毛笔在中间竖着写下蹩脚的\"杂\"字，看起来就像\"九十八\"。\n\n再加上在注册域名备案时出了点绊子，最后不知道起什么名了，那就按照这个思路给网站起名叫\"杂货铺\"吧，域名就是现在的 [blog.98store.top](https://blog.98store.top) 。\n\n网站内容也打算迎合网站名称，不只局限技术，放一些自己兴趣所在的东西。\n\n不管怎样，还是\n\n# 欢迎您来到杂货铺\n","tags":["归档"],"categories":["归档"]}]