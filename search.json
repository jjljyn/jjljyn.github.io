[{"title":"CocosCreator坐标转换","url":"/2018/12/05/cocos-creator-coordinate-transformation/","content":"# Cocos Creator 坐标转换\n\n实现场景中某个子节点从A点移动到B点的动画\n\n```javascript\nvar node = cc.find('Canvas/node');\n\n// 获取世界坐标中心的坐标\nvar world_center = cc.find('Canvas/bg').convertToWorldSpaceAR(cc.v2(0,-50));\n\n// 将世界中心转为相对父节点的坐标\nvar from = seat.convertToNodeSpaceAR(world_center) ;\n\n// 获取当前 node 相对父节点的坐标\nvar to = node.getPosition();\n\n// 移动\nnode.setPosition(from);  // 从场景中心\nvar action = cc.moveTo(0.5, to);  // 移动到node原来的位置\nnode.runAction(action);\n\n```\n\n","tags":["cocos","creator"]},{"title":"Javascript设计模式4 -- 代理模式","url":"/2018/12/04/javascript-design-4/","content":"# 代理模式\n\n代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。\n\n代理模式包括许多小分类，在JavaScript开发中最常用的是**虚拟代理**和**缓存代理**。\n\n> 代理模式的变体种类非常多，限于篇幅及其在JavaScript中的适用性只是介绍一下\n> - 防火墙代理：控制网络资源的访问，保护主题不让“坏人”接近。\n> - 远程代理：为一个对象在不同的地址空间提供局部代表，在Java中，远程代理可以是另一个虚拟机中的对象。\n> - 保护代理：用于对象应该有不同访问权限的情况。\n> - 智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。\n> - 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型运用场景。\n  \n\n## 虚拟代理\n\n### 虚拟代理实现图片预加载\n```javascript\n/**\n* 创建图片节点\n* @type {{setSrc}}\n*/\nvar myImage = (function() {\n  var imageNode = document.createElement('img');\n  document.body.appendChild(imageNode);\n  \n  return {\n    setSrc: function(src) {\n      imageNode.src = src;\n    }\n  }\n})();\n\n/**\n* 加载真实图片前，先显示加载图片\n* @type {{setSrc}}\n*/\nvar proxyImage = (function() {\n  var img = new Image();\n  img.onload = function() {\n    myImage.setSrc( this.src );  // 此处this指的是img，src指的是下面代码`img.src`\n  }\n  \n  return {\n    setSrc: function(src) {\n      myImage.setSrc('http://proxy.loading.png')\n      img.src = src;\n    }\n  }\n})();\n\nproxyImage.setSrc('http://real.image.path.image.png');\n```\n\n### 虚拟代理合并HTTP请求\n\n假设点击勾选框发出请求，需要同步相应的资源。快速点击会发出大量请求造成后端很大压力。这里实现没两秒合并发送一次请求。\n```html\n<body>\n    <input type=\"checkbox\" id=\"1\"></input>1\n    <input type=\"checkbox\" id=\"2\"></input>2\n    <input type=\"checkbox\" id=\"3\"></input>3\n    <input type=\"checkbox\" id=\"4\"></input>4\n    <input type=\"checkbox\" id=\"5\"></input>5\n    <input type=\"checkbox\" id=\"6\"></input>6\n    <input type=\"checkbox\" id=\"7\"></input>7\n    <input type=\"checkbox\" id=\"8\"></input>8\n    <input type=\"checkbox\" id=\"9\"></input>9\n</body>\n```\n\n```javascript\nvar send = (function(id) {\n  console.log('合并发送请求，ID为:'+id)\n})();\n\nvar proxySend = (function() {\n  var cache = [],  // 暂时保存需要id\n      timer;\n  \n  return function(id) {\n    cache.push(id)\n    if(timer){  // 同一时间只能有一个time，以免被覆盖\n      return;\n    }\n    \n    timer = setTimeout(function() {\n      send( cache.join(',') );\n      timer = null;   // 清除定时器\n      cache.length = 0;  // 清空cache\n    }, 2000)\n    \n  }\n})();\n\nvar checkBoxes = document.getElementsByTagName('input');\n\nfor(var i=0,box;box=checkBoxes[i++];){\n  box.onclick = function() {\n    if(this.checked === true){\n      proxySend(box.id)\n    }\n  }\n  \n}\n```\n\n\n## 缓存代理\n\n```javascript\n/**\n* 创建乘积函数\n* @return {number}\n*/\nvar mult = function() {\n  var a = 1;\n  for(var i = 0; i < arguments.length; i++ ){\n    a = a * arguments[i];\n  }\n  return a;\n}\n\n/**\n* 创建缓存代理函数\n* @type {function(): Function}\n*/\nvar proxyMult = (function() {\n  var cache = {};\n  \n  return function() {\n    var args = Array.prototype.join.call(arguments, ',');  // '1,2,3'\n    if(args in cache){  // 如果cache中有键为'1,2,3'的值，则直接输出\n      return cache[args];\n    }\n    return cache[args] = mult.apply(this,arguments);\n  }\n})\n\nproxyMult(1,2,3);  // 经过mult函数\nproxyMult(1,2,3);  // 直接从cache中取\n```\n可以缓存代理用于ajax异步请求数据\n\n`本文内容摘自《Javascript设计模式与实际开发》，如有疑问请评论。`\n","tags":["JavaScript","设计模式","代理模式"]},{"title":"Javascript设计模式3 -- 策略模式","url":"/2018/11/27/javascript-design-3/","content":"# 策略模式\n\n策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。\n\n> 一个基于策略模式的程序至少由两部分组成。\n> - 第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。 \n> - 第二个部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。\n\n\n\n以下假设实现游戏中角色使用不同枪械造成不同伤害，按照策略模式封装\n\n### 传统面向对象方式封装\n```javascript\n// 封装 策略类\n\n/**\n * 手枪：伤害系数为1\n */\nvar Pistol = function(){};\n\nPistol.prototype.shoot = function(dps){\n    return dps * 1\n}\n\n/**\n * 霰弹枪：伤害系数为2\n */\nvar Shotgun = function(){};\n\nShotgun.prototype.shoot = function(dps){\n    return dps * 2\n}\n\n/**\n * 加农炮：伤害系数为10\n */\nvar Cannon = function(){};\n\nCannon.prototype.shoot = function(dps){\n    return dps * 10\n}\n\n\n// 封装 武器类\nvar WeaponsStrategy = function(){\n    this._dps = null;  // 原始伤害\n    this._weapon_type = null;  // 武器类型\n}\n/**\n * 设置伤害值\n * @param {伤害} dps \n */\nWeaponsStrategy.prototype.setDps = function(dps) {\n    this._dps = dps\n}\n/**\n * 设置武器类型策略\n * @param {类型} type \n */\nWeaponsStrategy.prototype.setWeaponType = function(type) {\n    this._weapon_type = type;\n}\n/**\n * 获取伤害值\n */\nWeaponsStrategy.prototype.getDps = function() {\n    return this._weapon_type.shoot(this._dps);\n}\n\n\nvar strategy = new WeaponsStrategy();\nstrategy.setDps(100);  // 设置基础伤害\n\nstrategy.setWeaponType(new Pistol());  // 设置 手枪 类型策略\nconsole.log(strategy.getDps());     // 输出：100\n\nstrategy.setWeaponType(new Shotgun());  // 设置 霰弹枪 类型策略\nconsole.log(strategy.getDps());      // 输出：200\n\nstrategy.setWeaponType(new Cannon());  // 设置 加农炮 类型策略\nconsole.log(strategy.getDps());     // 输出：1000\n```\n\n### JavaScript 版本的策略模式\n\n```javascript\n// 将策略类作为函数对象\nvar strategy = {\n  pistol: function(dps) {\n    return dps * 1\n  },\n  shotgun: function(dps) {\n    return dps * 2\n  },\n  cannon: function(dps) {\n    return dps * 10\n  }\n}\n\n// 伤害输出\nvar damage = function(type, dps) {\n  return strategy[type](dps)\n}\n\nconsole.log(damage('pistol', 10)) // 输出:100\nconsole.log(damage('shotgun', 10)) // 输出:200\nconsole.log(damage('cannon', 10)) // 输出:1000\n\n```\n ### 策略模式实现表单验证\n ```html\n<html>\n    <body>\n        <form action=\"http:// xxx.com/register\" id=\"registerForm\" method=\"post\">\n            请输入用户名：<input type=\"text\" name=\"userName\"/ >\n            请输入密码：<input type=\"text\" name=\"password\"/ >\n            请输入手机号码：<input type=\"text\" name=\"phoneNumber\"/ >\n            <button>提交</button>\n        </form>\n    <script>\n\n    /***********************策略对象**************************/\n        \n    // 封装验证规则\n    var strategies = {\n        isNonEmpty: function( value, errorMsg ){\n            if ( value === '' ){\n                return errorMsg;\n            }\n        },\n        minLength: function( value, length, errorMsg ){\n            if ( value.length < length ){\n                return errorMsg;\n            }\n        },\n        isMobile: function( value, errorMsg ){\n            if ( !/(^1[3|5|8][0-9]{9}$)/.test( value ) ){\n                return errorMsg;\n            }\n        }\n    };\n\n    /***********************Validator 类**************************/\n\n    // 暂存数组\n    var Validator = function(){\n        this.cache = [];\n    };\n\n    // 添加验证项\n    Validator.prototype.add = function( dom, rules ){\n\n        var self = this;\n\n        for ( var i = 0, rule; rule = rules[ i++ ]; ){\n            (function( rule ){\n                var strategyAry = rule.strategy.split( ':' );  // 例['isNotEmpty']或['minLength',  6]\n                var errorMsg = rule.errorMsg;\n\n                self.cache.push(function(){\n                    var strategy = strategyAry.shift();  // 顶部弹出策略名\n                    strategyAry.unshift( dom.value );  // 顶部插入表单的value\n                    strategyAry.push( errorMsg );  // 尾部插入errmsg，形成`(value,errmsg)`或者`(value,length,errmsg)`\n                    return strategies[ strategy ].apply( null, strategyAry );\n                });\n            })( rule )\n        }\n\n    };\n\n    // 开始验证暂存数组的项\n    Validator.prototype.start = function(){\n        for ( var i = 0, validatorFunc; validatorFunc = this.cache[ i++ ]; ){\n            var errorMsg = validatorFunc();\n            if ( errorMsg ){\n                return errorMsg;\n            }\n        }\n    };\n\n    /***********************客户调用代码**************************/\n\n    var registerForm = document.getElementById( 'registerForm' );\n\n    var validataFunc = function(){\n        var validator = new Validator();\n\n        // 对userName验证空和最小长度\n        validator.add( registerForm.userName, [{\n            strategy: 'isNonEmpty',\n            errorMsg: '用户名不能为空'\n        }, {\n            strategy: 'minLength:10',\n            errorMsg: '用户名长度不能小于10位'\n        }]);\n\n        // 对password验证最小长度 \n        validator.add( registerForm.password, [{\n            strategy: 'minLength:6',\n            errorMsg: '密码长度不能小于6位'\n        }]);\n\n        // 对phoneNumber验证合法性\n        validator.add( registerForm.phoneNumber, [{\n            strategy: 'isMobile',\n            errorMsg: '手机号码格式不正确'\n        }]);\n\n        var errorMsg = validator.start();\n        return errorMsg;\n    }\n\n    // 表达提交时验证并对错误提示\n    registerForm.onsubmit = function(){\n         var errorMsg = validataFunc();\n\n         if ( errorMsg ){\n              alert ( errorMsg );\n              return false;\n         }\n     };\n    \n     </script>\n    </body>\n</html>\n```\n\n`本文内容摘自《Javascript设计模式与实际开发》，如有疑问请评论。`","tags":["JavaScript","设计模式","策略模式"]},{"title":"Javascript设计模式2 -- 单例模式","url":"/2018/11/20/javascript-design-2/","content":"# 单例模式\n\n> 定义：*保证一个类仅有一个实例，并提供一个访问它的全局访问点。*\n\n> 场景：当单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。\n\n## 实现单例模式\n```javascript\nvar Singleton = function( name ){\n    this.name = name;\n};\n\nSingleton.prototype.getName = function(){\n    console.log ( this.name );\n};\n\nSingleton.getInstance = (function(){\n    var instance = null;\n    return function( name ){\n        if ( !instance ){\n            instance = new Singleton( name );\n        }\n        return instance;\n    }\n})();\n\nvar a  =  Singleton.getInstance('sven1');\na.getName()  // 输出：sven1\nvar b = Singleton.getInstance('sven2');\nb.getName()  // 输出：sven1\n```\n## JavaScript中的单例模式\nJavaScript其实是一门无类（class-free）语言，也正因为如此，生搬单例模式的概念并无意义。在JavaScript中创建对象的方法非常简单，既然我们只需要一个“唯一”的对象，为什么要为它先创建一个“类”呢？这无异于穿棉衣洗澡，传统的单例模式实现在JavaScript中并不适用。\n\n单例模式的核心是确保只有一个实例，并提供全局访问。\n\n\n### 使用命名空间\n```javascript\nvar MyApp = {};\n\nMyApp.namespace = function( name ){\n    var parts = name.split( '.' );\n    var current = MyApp;  // 由于JavaScript对象赋值是深拷贝，所以current改变则MyApp改变\n    for ( var i in parts ){\n        if ( !current[ parts[ i ] ] ){\n            current[ parts[ i ] ] = {};\n        }\n        current = current[ parts[ i ] ];\n    }\n};\n\nMyApp.namespace( 'event' );\nMyApp.namespace( 'dom.style' );\n\nconsole.log(MyApp)  \n/* 输出：\n* {\n*   namespace: f (name),\n*   event: {},\n*   dom:{\n*       style: {}\n*     }\n* }\n*/\n```\n### 使用闭包封装私有变量\n```javascript\nvar user = (function(){\n    var __name = 'sven',  // 常用 __name 和 __age 表示私有变量\n        __age = 29;\n\n    return {\n        getUserInfo: function(){\n            return __name + '-' + __age;\n        }\n    }\n\n})();\n```\n## 惰性单例\n\n*惰性单例指的是在需要的时候才创建对象实例*。\n\n当点击【登录】按钮时再去创建悬浮框\n```html\n<html>\n    <body>\n        <button id=\"loginBtn\">登录</button>\n    </body>\n\n<script>\n    var createLoginLayer = (function(){\n        var div;                            // 用div变量标识是否已经创建了悬浮框\n        return function(){\n            if ( !div ){\n                div = document.createElement( 'div' );\n                div.innerHTML = '我是登录浮窗';\n                div.style.display = 'none';\n                document.body.appendChild( div );\n            }\n    \n            return div;\n        }\n    })();\n    \n    document.getElementById( 'loginBtn' ).onclick = function(){\n        var loginLayer = createLoginLayer();\n        loginLayer.style.display = 'block';\n    };\n</script>\n</html>\n```\n\n## 通用的惰性单例\n\n把*创建实例对象*的职责和*管理单例的职责*分别放置在两个方法里，这两个方法可以独立变化而互不影响，\n\n但是它们连接在一起的时候，就完成了创建唯一实例对象的功能。\n\n```javascript\n/**\n* 管理单例职责\n* 将如下部分提取出来\n* var obj;\n* if(!obj) { obj = xxx; }\n* return obj\n*/\nvar getSingle = function(fn) {\n  var single;\n  return function (){\n    return result || ( result = fn.apply(this, arguments) )\n  }\n}\n\n/**\n* 创建实例对象\n*/\nvar createLayout = function() {\n  // 创建登录悬浮窗\n  var div = document.createElement('div');\n  div.innerHTML = '我是登录悬浮窗口';\n  div.display = 'none';\n  document.body.appendChild( div );\n}\n\ndocument.getElementById('loginBtn').onclick = function() {\n  var loginBox = getSingle( createLayout() );\n  loginBox.display = 'block';\n}\n```\n\n>`本文内容摘自《Javascript设计模式与实际开发》，如有疑问请评论。`","tags":["JavaScript","设计模式","单例模式"]},{"title":"Shell杀死指定进程","url":"/2018/11/14/shell-kill-specified-process/","content":"```bash\n#!/bin/sh\n\n# 用法：\n# $ bash kill_all.sh configs_local.js\n\nNAME=$1\n\nif [ -z $1 ];then\n\necho \"Hint enter for default process name 'configs_local.js'.\"\nread\nNAME='configs_local.js'\n\nfi\n\nread -p \"Do you really want to kill all process which is match '$NAME'?(Y/n).\" -n 1 FLAG\necho -e \"\\n\"\n\nif [[ -n \"$FLAG\" && $FLAG = 'Y' ]];\nthen\n\necho \"Process name include '$NAME' \"\nID=`ps -ef | grep \"$NAME\" | grep -v \"$0\" | grep -v \"grep\" | awk '{print $2}'`\necho $ID\necho \"---------------\"\nfor id in $ID\ndo\nkill -9 $id\necho \"killed $id\"\ndone\necho \"---------------\"\n\nelse\n\necho 'Bye Bye';\n\nfi\n```\n1. 将之保存为`killprocess.sh`\n2. 调用`./killprocess.sh programmename`。其中`programme`可以为程序名字，也可以是启动程序时的命令行，只要能在`ps -ef | grep programmename` 之后出现所有的该程序对应的进程即可\n\n\n> `awk`命令简介：\n> awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。\n\n基础用法见：[linux awk命令详解](https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html)。\n\n详习用法见：[The GNU Awk User’s Guide](http://www.gnu.org/software/gawk/manual/gawk.html)","tags":["shell","node.js"]},{"title":"this、call和apply","url":"/2018/11/13/this-call-apply/","content":"> `JavaScript`中的`this`总是指向一个对象，具体指向哪个对象是**「在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境」。**\n\n# this\n\n`this`的指向大致分为四种：\n\n## 1. 作为对象的方法引用\n\n当某个对象中有函数作为属性并且被调用时，函数中的`this`会指向当前对象。\n```javascript\nvar obj = {\n  a:1,\n  getA: function() {\n    console.log(this === obj)   // 输出：true \n    console.log(this.a)   //  输出：1\n  }\n};\n```\n\n## 2. 作为普通函数调用\n\n普通的函数中包含`this`并且被调用时，`this`总是指向全局对象。浏览器中的全局对象就是`window`对象。\n```javascript\nwindow.name = 'window';\n\nvar getName = function() {\n  return this.name;\n};\nconsole.log(getName())  // 输出：window\n```\n\n## 3. 构造器调用\n\n**Javascript中没有类**，但是可以从构造器中创建对象，同时也提供了`new`运算符，使得构造器看起来更像一个类。\n当用`new`运算符调用函数时，总会返回一个对象，通常情况下，构造器里的`this`就指向返回的这个对象。\n```javascript\nvar name = function() {\n  this.name = 'steven';\n};\n\nvar obj = new name();\nconsole.log(obj.name)  //输出：steven\n```\n但用`new`调用构造器时，需要注意如果**显式**的返回一个`object`对象，那么`this`会指向这个返回的对象。如果显式返回一个非`object`的类型则不会影响。\nvar name = function() {\n  this.name = 'steven';\n  return {\n    name: 'John'\n  }\n};\n\nvar obj = new name();\nconsole.log(obj.name)  //输出：John\n\n\n## 4.  `Function.prototype.call`或者`Function.prototype.apply`调用\n\n用`Function.prototype.call`或者`Function.prototype.apply`可以动态改变传入函数的`this`。\n```javascript\nvar person1 = {\n  name: 'steven',\n  getName: function() {\n    return this.name\n  }\n};\n\nvar person2 = {\n  name: 'John'\n}\n\nconsole.log(person1.getName())  // 输出：steven\nconsole.log(person1.getName.call(person2))   // 输出：John\n```\n\n\n# call和apply的区别 \n\n`Function.prototype.call`和`Function.prototype.apply`都是非常常用的方法。它们的作用一模一样，区别仅在于传入参数形式的不同。\n\n详细用法参见[MDN web docs Function.prototype.call](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)、[MDN web docs Function.prototype.apply](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n\n# call和apply的用途 \n\n## 1. 改变`this`指向\n### '丢失'的`this`\n```html\n<html>\n    <body>\n        <div id=\"div1\">我是一个div</div>\n    </body>\n    <script>\n\n    var getId = document.getElementById;\n    getId( 'div1' );\n\n    </script>\n</html>\n```\n上述代码执行时会报错，因为调用`getId()`时，相当于调用普通函数，则`document.getElementById`中内部实现需要用到的`this`默认指向全家对象`window`并不是原本期望的`document`。\n\n```javascript\ndocument.getElementById = (function(fn) {\n  return function() {\n    return fn.apply(document, arguments)  // apply 中第一个参数 document 就是将 document.getElementById内部的this指向到document\n  }\n})(document.getElementById);  // 这里括号内的方法 document.getElementById 就是上方的 fn\n\nvar getId = document.getElementById;\ngetId('div')\n```\n> `(function(){ /* code */})();`是[IIFE立即执行函数模式](https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F)语法，可以让函数在定义后立即被执行。\n> 第一部分是包围在圆括号运算符()里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。\n  第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。\n\n## 2. `Function.prototype.bind`\n\n大部分高级浏览器都实现了内置的`Function.prototype.bind`，用来指定函数内部的`this`指向，我们来实现一下`Function.prototype.bind`，代码如下：\n\n```javascript\nFunction.prototype.bind = function( context ){\n    var self = this;        // 保存原函数\n    return function(){        // 返回一个新的函数\n        return self.apply( context, arguments );    // 执行新的函数的时候，会把之前传入的context\n                                                    // 当作新函数体内的this\n    }\n};\n\nvar obj = {\n    name: 'sven'\n};\n\nvar func = function(){\n    console.log ( this.name );    // 输出：sven\n}.bind( obj);\n\nfunc();\n```\n## 3. 借用其他对象的方法\n\n函数的参数列表`arguments`是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，我们常常会借用`Array.prototype`对象上的方法。比如想往`arguments`中添加一个新的元素，通常会借用`Array.prototype.push`：\n```javascript\n(function(){\n  console.log(arguments);   // 输出：Arguments(2) [1,2]\n  Array.prototype.push.call( arguments, 3 );\n  console.log ( arguments );    // 输出：Arguments(3) [1,2,3]\n})( 1, 2 );\n```\n\n>`本文内容摘自《Javascript设计模式与实际开发》，如有疑问请评论。`","tags":["Javascript"]},{"title":"Javascript设计模式1 -- 原型模式","url":"/2018/11/06/javascript-design-1/","content":"### 原型模式\n原型模式是一种设计模式，也是一种编程泛型，它构成了JavaScript这门语言的根本。\n\n原型模式的实现关键，是语言本身是否提供了`clone`方法。ECMAScript5提供了`Object.create`方法，可以用来克隆对象。代码如下\n```javascript\n// 例如是在写一个飞机大战的游戏\nvar Plane = function () {\n  this.blood = 100;\n  this.attackLevel = 1;\n  this.defenseLevel = 1;\n}\n\nvar plane =  new Plane();\nplane.blood = 500;\nplane.attackLevel = 10;\nplane.defenseLevel = 5;\n\nvar clonePlane = Object.create(plane);\nconsole.log(clonePlane.blood)  // 500\nconsole.log(clonePlane.attackLevel)   // 10\nconsole.log(clonePlane.defenseLevel)  // 5\n```\n在不支持`Object.create`方法的浏览器中，则可以使用以下代码\n```javascript\nObject.create = Object.create || function(obj) {\n  var fn = function() {};\n  fn.prototype = obj;\n  return new fn();\n}\n```\n\n### 原型编程范型的一些规则\nJavaScript本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的。所以原型模式不仅仅是一种设计模式，也是一种编程范型。\n\n原型编程中的一个重要特性，即当对象无法响应某个请求时，会把该请求委托给它自己的原型。\n\n原型编程范型至少包括以下基本规则：\n- 所有数据都是对象\n- 要得到一个对象，不是用过实例化类，而是找到一个对象作为原型并克隆它\n- 对象会记住它的原型\n- 如果对象无法响应某个请求，它会把这个请求委托给自己的原型。\n\n\n\n>`本文内容摘自《Javascript设计模式与实际开发》，如有疑问请评论。`","tags":["JavaScript","设计模式","原型模式"]},{"title":"新的开始","url":"/2018/11/01/hello-world/","content":"\n### 新的开始\n\n一直想有个地方，专门承载一些自己的小兴趣，记录自己的成长\n\n用过简书，虽然很好的支持Markdown，但是草稿多了搜索是个问题，所以暂时不用了。\n\n用过Evernote，虽然支持多端使用，但是不支持Markdown语法而且太封闭，加上自己又有输出和交流的念头，所以记录项目和写草稿。\n\n那这个个人的小网站就是能满足自己需求的地方。\n\n做技术是一个积累的过程，积累到一定程度是能够输出的，而且也会有及积极输出的欲望。\n\n就目前来说，自己积累沉淀的内容质量并不高，适合自己的方式方法、主题及内容尚未成型\n\n希望能看到内容的朋友能够多多给予意见和建议，以及一些正面反馈。\n\n上小学的时候，学校举办一次自制校报的比赛，我就很没有创意的起名叫做\"杂报\"，\n\n而且用毛笔在中间竖着写下蹩脚的\"杂\"字，看起来就像\"九十八\"。\n\n再加上在注册域名备案时出了点绊子，最后不知道起什么名了，那就按照这个思路给网站起名叫\"杂货铺\"吧，域名就是现在的 [blog.98store.top](https://blog.98store.top) 。\n\n网站内容也打算迎合网站名称，不只局限技术，放一些自己兴趣所在的东西。\n\n不管怎样，还是\n\n# 欢迎您来到杂货铺\n","tags":["归档"],"categories":["归档"]}]