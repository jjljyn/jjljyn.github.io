<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杂货铺</title>
  <icon>https://www.gravatar.com/avatar/78dfb1fb53867356c0a9c9876dee56c6</icon>
  <subtitle>杂 - 九十八的杂</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jjljyn.github.io/"/>
  <updated>2018-11-13T12:02:53.394Z</updated>
  <id>https://jjljyn.github.io/</id>
  
  <author>
    <name>Junliang Jia</name>
    <email>julianjia1009@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>this、call和apply</title>
    <link href="https://jjljyn.github.io/2018/11/13/this-call-apply/"/>
    <id>https://jjljyn.github.io/2018/11/13/this-call-apply/</id>
    <published>2018-11-13T04:43:39.000Z</published>
    <updated>2018-11-13T12:02:53.394Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>JavaScript</code>中的<code>this</code>总是指向一个对象，具体指向哪个对象是<strong>「在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境」。</strong></p></blockquote><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p><code>this</code>的指向大致分为四种：</p><h2 id="1-作为对象的方法引用"><a href="#1-作为对象的方法引用" class="headerlink" title="1. 作为对象的方法引用"></a>1. 作为对象的方法引用</h2><p>当某个对象中有函数作为属性并且被调用时，函数中的<code>this</code>会指向当前对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">1</span>,</span><br><span class="line">  getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj)   <span class="comment">// 输出：true </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)   <span class="comment">//  输出：1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="2-作为普通函数调用"><a href="#2-作为普通函数调用" class="headerlink" title="2. 作为普通函数调用"></a>2. 作为普通函数调用</h2><p>普通的函数中包含<code>this</code>并且被调用时，<code>this</code>总是指向全局对象。浏览器中的全局对象就是<code>window</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'window'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(getName())  <span class="comment">// 输出：window</span></span><br></pre></td></tr></table></figure></p><h2 id="3-构造器调用"><a href="#3-构造器调用" class="headerlink" title="3. 构造器调用"></a>3. 构造器调用</h2><p><strong>Javascript中没有类</strong>，但是可以从构造器中创建对象，同时也提供了<code>new</code>运算符，使得构造器看起来更像一个类。<br>当用<code>new</code>运算符调用函数时，总会返回一个对象，通常情况下，构造器里的<code>this</code>就指向返回的这个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'steven'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> name();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)  <span class="comment">//输出：steven</span></span><br></pre></td></tr></table></figure></p><p>但用<code>new</code>调用构造器时，需要注意如果<strong>显式</strong>的返回一个<code>object</code>对象，那么<code>this</code>会指向这个返回的对象。如果显式返回一个非<code>object</code>的类型则不会影响。<br>var name = function() {<br>  this.name = ‘steven’;<br>  return {<br>    name: ‘John’<br>  }<br>};</p><p>var obj = new name();<br>console.log(obj.name)  //输出：John</p><h2 id="4-Function-prototype-call或者Function-prototype-apply调用"><a href="#4-Function-prototype-call或者Function-prototype-apply调用" class="headerlink" title="4.  Function.prototype.call或者Function.prototype.apply调用"></a>4.  <code>Function.prototype.call</code>或者<code>Function.prototype.apply</code>调用</h2><p>用<code>Function.prototype.call</code>或者<code>Function.prototype.apply</code>可以动态改变传入函数的<code>this</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'steven'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'John'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.getName())  <span class="comment">// 输出：steven</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.getName.call(person2))   <span class="comment">// 输出：John</span></span><br></pre></td></tr></table></figure></p><h1 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h1><p><code>Function.prototype.call</code>和<code>Function.prototype.apply</code>都是非常常用的方法。它们的作用一模一样，区别仅在于传入参数形式的不同。</p><p>详细用法参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">MDN web docs Function.prototype.call</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">MDN web docs Function.prototype.apply</a></p><h1 id="call和apply的用途"><a href="#call和apply的用途" class="headerlink" title="call和apply的用途"></a>call和apply的用途</h1><h2 id="1-改变this指向"><a href="#1-改变this指向" class="headerlink" title="1. 改变this指向"></a>1. 改变<code>this</code>指向</h2><h3 id="‘丢失’的this"><a href="#‘丢失’的this" class="headerlink" title="‘丢失’的this"></a>‘丢失’的<code>this</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>我是一个div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span></span><br><span class="line"><span class="javascript">    getId( <span class="string">'div1'</span> );</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码执行时会报错，因为调用<code>getId()</code>时，相当于调用普通函数，则<code>document.getElementById</code>中内部实现需要用到的<code>this</code>默认指向全家对象<code>window</code>并不是原本期望的<code>document</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById = (<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">document</span>, <span class="built_in">arguments</span>)  <span class="comment">// apply 中第一个参数 document 就是将 document.getElementById内部的this指向到document</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">document</span>.getElementById);  <span class="comment">// 这里括号内的方法 document.getElementById 就是上方的 fn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line">getId(<span class="string">'div'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>(function(){ /* code */})();</code>是<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">IIFE立即执行函数模式</a>语法，可以让函数在定义后立即被执行。<br>第一部分是包围在圆括号运算符()里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。<br>  第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</p></blockquote><h2 id="2-Function-prototype-bind"><a href="#2-Function-prototype-bind" class="headerlink" title="2. Function.prototype.bind"></a>2. <code>Function.prototype.bind</code></h2><p>大部分高级浏览器都实现了内置的<code>Function.prototype.bind</code>，用来指定函数内部的<code>this</code>指向，我们来实现一下<code>Function.prototype.bind</code>，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"> context </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;        <span class="comment">// 保存原函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;        <span class="comment">// 返回一个新的函数</span></span><br><span class="line">        <span class="keyword">return</span> self.apply( context, <span class="built_in">arguments</span> );    <span class="comment">// 执行新的函数的时候，会把之前传入的context</span></span><br><span class="line">                                                    <span class="comment">// 当作新函数体内的this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'sven'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log ( <span class="keyword">this</span>.name );    <span class="comment">// 输出：sven</span></span><br><span class="line">&#125;.bind( obj);</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure><h2 id="3-借用其他对象的方法"><a href="#3-借用其他对象的方法" class="headerlink" title="3. 借用其他对象的方法"></a>3. 借用其他对象的方法</h2><p>函数的参数列表<code>arguments</code>是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，我们常常会借用<code>Array.prototype</code>对象上的方法。比如想往<code>arguments</code>中添加一个新的元素，通常会借用<code>Array.prototype.push</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);   <span class="comment">// 输出：Arguments(2) [1,2]</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.push.call( <span class="built_in">arguments</span>, <span class="number">3</span> );</span><br><span class="line">  <span class="built_in">console</span>.log ( <span class="built_in">arguments</span> );    <span class="comment">// 输出：Arguments(3) [1,2,3]</span></span><br><span class="line">&#125;)( <span class="number">1</span>, <span class="number">2</span> );</span><br></pre></td></tr></table></figure></p><blockquote><p><code>本文内容摘自《Javascript设计模式与实际开发》，如有疑问请评论。</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;中的&lt;code&gt;this&lt;/code&gt;总是指向一个对象，具体指向哪个对象是&lt;strong&gt;「在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境」。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://jjljyn.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript设计模式1 -- 原型模式</title>
    <link href="https://jjljyn.github.io/2018/11/06/javascript-design-1/"/>
    <id>https://jjljyn.github.io/2018/11/06/javascript-design-1/</id>
    <published>2018-11-06T14:11:32.000Z</published>
    <updated>2018-11-13T04:43:06.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式是一种设计模式，也是一种编程泛型，它构成了JavaScript这门语言的根本。</p><p>原型模式的实现关键，是语言本身是否提供了<code>clone</code>方法。ECMAScript5提供了<code>Object.create</code>方法，可以用来克隆对象。代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如是在写一个飞机大战的游戏</span></span><br><span class="line"><span class="keyword">var</span> Plane = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">this</span>.attackLevel = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.defenseLevel = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plane =  <span class="keyword">new</span> Plane();</span><br><span class="line">plane.blood = <span class="number">500</span>;</span><br><span class="line">plane.attackLevel = <span class="number">10</span>;</span><br><span class="line">plane.defenseLevel = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clonePlane = <span class="built_in">Object</span>.create(plane);</span><br><span class="line"><span class="built_in">console</span>.log(clonePlane.blood)  <span class="comment">// 500</span></span><br><span class="line"><span class="built_in">console</span>.log(clonePlane.attackLevel)   <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(clonePlane.defenseLevel)  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p>在不支持<code>Object.create</code>方法的浏览器中，则可以使用以下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="built_in">Object</span>.create || <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  fn.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="原型编程范型的一些规则"><a href="#原型编程范型的一些规则" class="headerlink" title="原型编程范型的一些规则"></a>原型编程范型的一些规则</h3><p>JavaScript本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的。所以原型模式不仅仅是一种设计模式，也是一种编程范型。</p><p>原型编程中的一个重要特性，即当对象无法响应某个请求时，会把该请求委托给它自己的原型。</p><p>原型编程范型至少包括以下基本规则：</p><ul><li>所有数据都是对象</li><li>要得到一个对象，不是用过实例化类，而是找到一个对象作为原型并克隆它</li><li>对象会记住它的原型</li><li>如果对象无法响应某个请求，它会把这个请求委托给自己的原型。</li></ul><blockquote><p><code>本文内容摘自《Javascript设计模式与实际开发》，如有疑问请评论。</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h3&gt;&lt;p&gt;原型模式是一种设计模式，也是一种编程泛型，它构成了JavaScript这门语言的根本。&lt;/p&gt;
&lt;p&gt;原型模式的实现关键，是
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://jjljyn.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="https://jjljyn.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="https://jjljyn.github.io/2018/11/01/hello-world/"/>
    <id>https://jjljyn.github.io/2018/11/01/hello-world/</id>
    <published>2018-10-31T16:31:11.863Z</published>
    <updated>2018-10-31T16:31:11.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h3><p>一直想有个地方，专门承载一些自己的小兴趣，记录自己的成长</p><p>用过简书，虽然很好的支持Markdown，但是草稿多了搜索是个问题，所以暂时不用了。</p><p>用过Evernote，虽然支持多端使用，但是不支持Markdown语法而且太封闭，加上自己又有输出和交流的念头，所以记录项目和写草稿。</p><p>那这个个人的小网站就是能满足自己需求的地方。</p><p>做技术是一个积累的过程，积累到一定程度是能够输出的，而且也会有及积极输出的欲望。</p><p>就目前来说，自己积累沉淀的内容质量并不高，适合自己的方式方法、主题及内容尚未成型</p><p>希望能看到内容的朋友能够多多给予意见和建议，以及一些正面反馈。</p><p>上小学的时候，学校举办一次自制校报的比赛，我就很没有创意的起名叫做”杂报”，</p><p>而且用毛笔在中间竖着写下蹩脚的”杂”字，看起来就像”九十八”。</p><p>再加上在注册域名备案时出了点绊子，最后不知道起什么名了，那就按照这个思路给网站起名叫”杂货铺”吧，域名就是现在的 <a href="https://blog.98store.top" target="_blank" rel="noopener">blog.98store.top</a> 。</p><p>网站内容也打算迎合网站名称，不只局限技术，放一些自己兴趣所在的东西。</p><p>不管怎样，还是</p><h1 id="欢迎您来到杂货铺"><a href="#欢迎您来到杂货铺" class="headerlink" title="欢迎您来到杂货铺"></a>欢迎您来到杂货铺</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;新的开始&quot;&gt;&lt;a href=&quot;#新的开始&quot; class=&quot;headerlink&quot; title=&quot;新的开始&quot;&gt;&lt;/a&gt;新的开始&lt;/h3&gt;&lt;p&gt;一直想有个地方，专门承载一些自己的小兴趣，记录自己的成长&lt;/p&gt;
&lt;p&gt;用过简书，虽然很好的支持Markdown，但是草稿多
      
    
    </summary>
    
      <category term="归档" scheme="https://jjljyn.github.io/categories/%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="归档" scheme="https://jjljyn.github.io/tags/%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
</feed>
